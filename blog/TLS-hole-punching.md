---
"slug": "tls-hole-punching"
title: "TLS hole punching"
description: ""
date: 2021-07-08
---

[Hole punching](https://en.wikipedia.org/wiki/Hole_punching_%28networking%29) is a technique that allows 2 peers on disparate private networks to communicate directly with each other. Hole punching exists because most routers on private home and office networks perform [network address translation](https://en.wikipedia.org/wiki/Network_address_translation) (NAT), a method that's grown in popularity under looming IPv4 address exhaustion. This means people browsing the web on a private NAT-ed network *do not* have globally unique, public IPv4 addresses to identify their devices. In fact, they typically "share" a public IP address assigned by their Internet Service Provider (ISP) with other devices on the network. NAT creates a mapping by modifying IP packet headers such that incoming traffic is routed to the appropriate device on the network. Suppose I'm checking my email on my phone and my roommate is simultaneously watching a movie on his laptop. NAT makes sure the traffic pertaining to the former is routed to my phone and traffic relating to the latter is routed to my roommate's computer.

In the case of most web communication, traffic is relayed from client to client by a server behind a globally unique IP address. This avoids direct communication between clients and, as a result, the issues it poses. Clients connect to a known entity that forwards information back and forth between them without having to worry about NAT routers dropping traffic. However, peer-to-peer (p2p) communication via hole punching offers potential security / privacy benefits as well as lower latency: traffic travels directly between peers without a "server detour".

If I want to connect directly to my friend on another network, I run into several issues thanks to NAT. First, my friend cannot give me a public IPv4 address to reach their device. They have a private IPv4 address, but this only works if I'm on the network as well. Even if they provide an IPv6 address that identifies their device, we still could have issues communicating. Routers usually drop unsolicited inbound traffic, including IPv6 traffic. If the router cannot correlate incoming traffic to contemporaneous outbound traffic, then it deems the traffic unsolicited. If I try to send packets to my friend's IPv6 address, chances are they won't make it to their device. If my friend and I send packets to each other at the same time, we *might* receive each other's packets. This process is difficult to coordinate though. To further complicate the situation, different routers implement NAT differently. If my friend's behind a [symmetric NAT](https://en.wikipedia.org/wiki/Network_address_translation#Symmetric_NAT), certain hole punching techniques won't work. This post details a hole punching procedure that allows two peers to establish a direct, reliable, and secure connection. This process should work for peers on many home networks, though I cannot guarantee it working across all networks at this time.

There are 2 types of hole punching, one for each major Internet transport protocol: [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) and [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol). UDP hole punching is the more prevalent of the two, commonly used for VoIP and gaming. Direct p2p communication improves latency, often times critical in realtime applications. UDP makes no promises regarding reliable delivery of data, but this "shortcoming" is preferable for certain use cases. If I'm video chatting my friend, it's ok if packets are dropped. Their video might freeze for a second and their audio might cut out. The more important point is, when the chat resumes, I see and hear the latest video and audio. I don't need or even want to receive the earlier media that was dropped.

TCP, on the other hand, ensures reliable delivery. Everything is eventually delivered in the order it was sent. Packets can still be dropped, but they'll be resent. This isn't ideal for video chatting my friend, but well suited for other use cases such as file sharing, where the entire content should eventually be delivered uncorrupted. Unforunately, TCP hole punching is more complicated than UDP hole punching. This stems from (1) the nature of the TCP protocol, (2) differing NAT implementations, and (3) the structure of socket APIs. I'll elaborate on each of these points and discuss how their interaction makes TCP hole punching difficult.

